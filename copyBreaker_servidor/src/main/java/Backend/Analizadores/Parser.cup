/*package e imports*/
package Backend.Analizadores;

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import Backend.Objetos.Resultado.RESULT;
import Backend.Objetos.Resultado.Metodo;
import Backend.Objetos.Resultado.Variable;
import Backend.Objetos.Token;
import Backend.Manejadores.ManejadorErrores;
import Backend.Objetos.Error;
import Backend.Objetos.Enums.SintaxError;
import Backend.Analizadores.ParserSym;

/*1. user code*/
class Parser;

action code{:
    int numeroVarsNumericas = 0;
    int numeroVarsObjetoCreadas;//lo add con tal de que se muestre el tipo y no la palabra objeto, para ser más específica y yo diría que eso es lo que querrían ver...
    int numeroVarCreadas = 0;    

    private void addInfoMetodo(String tipo, Object nombre){
        addInfoRestanteVariables(((tipo.equals("constructor"))?tipo:"metodo")+" "+Token.parseToken(nombre).getLexema());
        resultParcial.addMetodo(new Metodo(tipo, Token.parseToken(nombre).getLexema(), listaParametros));
        listaParametros = new ArrayList<>();//puesto que si quiero usar el clear, lo que debo hacer es tener una copia del contenido de la lista en una aux, de lo contrario tb se perderá el contenido que se recibió en el parámetro
    }

    private void addInfoVariables(String tipo, Object nombre){
        if(tipo != null){
            resultParcial.addVariable(new Variable(tipo, Token.parseToken(nombre).getLexema()));
        }else{
            resultParcial.addVariable(new Variable(Token.parseToken(nombre).getLexema()));            
        }  
        numeroVarCreadas++;      
    }

    private void addTipoNumericoVars(String tipo){
        ArrayList<Variable> variables = resultParcial.getVariables();

        for(int actual = (variables.size()-numeroVarsNumericas); actual < variables.size(); actual++){            
            variables.get(actual).setTipo(tipo);                                
        }
        numeroVarsNumericas = 0;
    }

    private void addTipoObjetoVars(String tipo){
        ArrayList<Variable> variables = resultParcial.getVariables();

        for(int actual = (variables.size()-numeroVarsObjetoCreadas); actual < variables.size(); actual++){            
            variables.get(actual).setTipo(tipo);                                
        }
        numeroVarsObjetoCreadas = 0;
    }

    private void addInfoRestanteVariables(String funcion){
        ArrayList<Variable> variables = resultParcial.getVariables();

        for(int actual = (variables.size()-numeroVarCreadas); actual < variables.size(); actual++){         
            variables.get(actual).setFuncion(" ", funcion);
        }
        
        numeroVarCreadas = 0;
    }//este se invoca en las def_var de los bloques: clase y método, puesto que ahí se completa la info...

    private void addError(Token token, int linea, int columna, SintaxError error){//tipoReporte = operacion o error                
        manejadorErrores.setError(new Error(resultParcial.getClase(0).getNombre(), ((token != null)?token.getLexema():""), linea, columna, error));
        
    }
:}/*el código que se encuentra aquí dentro NO puede ser accedido desde la clase...*/

parser code {:/*código que modifica el comportamiento del parser [sobreescribiendo o creado métodos]    */
    private ManejadorErrores manejadorErrores;
    private RESULT resultParcial;
    private ArrayList<Variable> listaParametros = new ArrayList<>();

    public Parser(Lexer lexer, RESULT resultadoLexer, ManejadorErrores manejadorErroresLex){/*nuevo constructor*/
        super(lexer);        

        manejadorErrores = manejadorErroresLex;
        resultParcial = resultadoLexer;//ya tiene el listado de comentarios y clase [que tiene 1 sola clase xD], agregados... aunque quizá halla un poco de riesgo, al establecer la clase en el lexer, nec que sea allá para que así se seteen sin tantas vueltas el campo función de las clases globales... de todos modos en un caso en el que todo está bien, el searlo en el lexer está bien, lo raro sucedería al haber errores xD
    }    

    public void report_fatal_error(String message, Object info){
        manejadorErrores.setError(new Error(resultParcial.getClase(0).getNombre(), ((info != null)?info.toString():""), -1, 
        -1, SintaxError.FATAL_ERROR));
    }

    protected int error_sync_size(){
        return 1;
    }/*para que establezca que con un token bien leido basta para recuperarse...   */
:}/*este si puede ser accedido desde el código...*/

/*2. terminales*/
terminal IIMPORT, CLASS, THIS, NEW, RETURN, BREAK;
terminal PUBLIC, PROTECTED, PRIVATE, FINAL, INT, DOUBLE, STRING, CHAR, BOOLEAN, OBJECT, OBJETO, NOMBRE, VOID;
terminal CADENA, NUMERO, BOOLEANO, CARACTER;/*hace falta objeto, pero aún no tengo imple como hacerlo por eso no lo add*/
terminal PUNTO_COMA, PUNTO, ASTERISCO, LLAVE_A, LLAVE_C, DOS_PUNTOS, COMA;
terminal MAS, RESTA, MENOS, DIV, IGUAL, PARENTESIS_A, PARENTESIS_C;
terminal FOR, WHILE, DO, IF, ELSE, SWITCH, CASE, DEFAULT;
terminal OPERADOR_RELACIONAL, OPERADOR_LOGICO, NO;

/*3. no terminales*/
non terminal inicio;
non terminal imports, iimport, direccion_import, direccion;
non terminal visibilidad, clase, def_clase, bloque_clase, sentencias_clase;
non terminal def_variable, def_tipo_variable;
non terminal creacion_variable_numero, variable_numero, creacion_variable_string, variable_string, creacion_variable_char, variable_char;
non terminal creacion_variable_boolean, variable_boolean, creacion_variable_object, variable_object, creacion_variable_objeto, variable_objeto;
non terminal def_metodo, cuerpo_def_metodo, def_metodo_constructor, cuerpo_metodo_constructor,def_metodo_tipo, cuerpo_metodo_numero, cuerpo_metodo_string, cuerpo_metodo_char, cuerpo_metodo_boolean;
non terminal cuerpo_metodo_object, cuerpo_metodo_objeto, def_metodo_void, cuerpo_metodo_void, parametros, parametro;
non terminal String tipo;
non terminal bloque, sentencias;
non terminal asignacion, tipos_asignacion/*, asignacion_multiple, contenido_asignacion_multiple*/;
non terminal contenido_variable, contenido_numero, contenido_string, permitidos, cualquier_contenido, opciones_cualquier_contenido, strings, contenido_char, contenido_boolean, contenido_object, contenido_objeto;
non terminal operacion_unaria, incremento, autoincremento, opciones_autoincremento, opciones_autoIncreMas;
non terminal ciclo, ciclo_for, asignacion_for, asignacion_completa_for, condiciones_for, incremento_for;
non terminal invocacion, cuerpo_invocacion_var, cuerpo_invocacion_metodo, argumentacion, argumentos, argumento;
non terminal sentencia_control, sentencia_if, sentencia_switch, cuerpo_switch, casos_normales, caso, caso_default, contenido_switch;
non terminal condicion, opcion_condicion, contenido_bool, contenido_condicion;
non terminal negaciones;
non terminal cuerpo_estructuras, bloque_general;
non terminal retorno, retorno_compuesto, retorno_variable, retorno_numero, retorno_string, retorno_char, retorno_boolean, retorno_object;
non terminal retorno_objeto, parada;

/*3.1. precedenca y asociatividad*/
precedence left MAS, RESTA;/*basado en la docu xD*/
precedence left ASTERISCO, DIV;/*no creo que me de problemas, al aparecer AST, también en direccion...*/
precedence left MENOS;

precedence left OPERADOR_LOGICO;
precedence left OPERADOR_RELACIONAL;/*yo diría que este es mayor en jerarquía que el lógico...*//*esperaría que no provocar más erorres [eso sí soy consciente de que eli 1 la noassoc:v xD]*/

//precedence left opciones_cualquier_contenido;//la agregué para que lea de primero el menos... pero no hizo nada ;-;

/*4. Reglas de producción*/
start with inicio;

inicio ::= imports clase                                    {:System.out.println("[S] clase con imports analizada");:}
         | clase                                            {:System.out.println("[S] clase analizada");:}
     //    | error                                            {:System.out.println("[S] error: FILE JAVA MALFORMED");:}
         ;

imports ::= imports iimport                                          {:System.out.println("[S] estructura: import [LISTA]");:}
          | iimport                                                  {:System.out.println("[S] estructura: import [UNICO]");:}
          | error:err  iimport                                       {:System.out.println("[S] error: SECTION OF IMPORTS WITH ERRORS");
                                                                       addError(Token.parseToken(err), errleft, errright, SintaxError.IMPORT_SECTION_WITH_ERRORS);:}
          ;

iimport ::= IIMPORT direccion_import PUNTO_COMA                             {:System.out.println("[S] estructura: iimport");:}
          ;

direccion_import ::= direccion PUNTO ASTERISCO                         {:System.out.println("[S] estructura: direccion_import [con *]");:}
                   | direccion                                         {:System.out.println("[S] estructura: direccion_import [sin *]");:}
                   | error:err                                         {:System.out.println("[S] error: MALFORMED IMPORT");
                                                                         addError(Token.parseToken(err), errleft, errright, SintaxError.IMPORT_MALFORMED);:}
                   ;/*dejo el símbolo de recu aquí como IIMPORT, o vuelvo a colocar el PC en lo de arribita, o el IIMPORT, allá mismo???*/

direccion ::= direccion PUNTO NOMBRE                          {:System.out.println("[S] substruct: direccion: LISTA");:}
            | NOMBRE PUNTO NOMBRE                             {:System.out.println("[S] substruct: direccion: PAREJA");:}
            //| error                                           {:System.out.println("[S] error: IMPORT's DIRECCION MALFORMED");:}
            ;

clase ::= visibilidad def_clase                                            {:System.out.println("[S] estructura: CLASE [visible]");:}
        | def_clase                                                        {:System.out.println("[S] estructura: CLASE [invisi]");:}
        | error:err                                                        {:System.out.println("[S] error: STRUCT OF CLASS EXPECTED: <visibilidad> CLASS <class_name> { <body> }");
                                                                             addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_CLASS_STRUCT);:}
        ;

visibilidad ::= PUBLIC                                                     {:System.out.println("[S] visibilidad: PUBLIC");:}
              | PROTECTED                                                  {:System.out.println("[S] visibilidad: PROTECTED");:}
              | PRIVATE                                                    {:System.out.println("[S] visibilidad: PRIVATE");:}
              | FINAL                                                      {:System.out.println("[S] visibilidad: FINAL");:}
        //      | error                                                      {:System.out.println("[S] error: VISIBILITY EXPECTED: public|protected|private|final");:}
              ;

def_clase ::= CLASS OBJETO LLAVE_A bloque_clase LLAVE_C                              {:System.out.println("[S] substruct: cuerpo_clase: CB");:}
            | CLASS OBJETO LLAVE_A LLAVE_C                                           {:System.out.println("[S] substruct: cuerpo_clase: SB");:}
      //      | error                                                                  {:System.out.println("[S] error: BAD CLASS STRUCT");:}
            ;

bloque_clase ::= bloque_clase sentencias_clase                             {:System.out.println("[S] bloque clases: +1 sentencia");:}
               | sentencias_clase                                          {:System.out.println("[S] bloque clases: 1 sentencia");:}
       //        | error                                                     {:System.out.println("[S] error: BAD CLASS BODY");:}
               ;

sentencias_clase ::= def_variable                                          {:System.out.println("[S] sentencia clases: def_var");
                                                                             addInfoRestanteVariables("clase "+resultParcial.getClase(0).getNombre());:}
                   | def_metodo                                            {:System.out.println("[S] sentencia clases: def_metodo");:}
        //           | error                                                 {:System.out.println("[S] error: SENTENCE EXPECTED: definición de variable o método");:}
                   ;

def_variable ::= visibilidad def_tipo_variable PUNTO_COMA                             {:System.out.println("[S] estructura: def_variable [visible]");:}
               | def_tipo_variable PUNTO_COMA                                         {:System.out.println("[S] estructura: def_variable [invisi]");:}
        //       | error                                                                {:System.out.println("[S] error: BAD VARIABLE DEFINITION, EXPECTED <visibility> <list vars> ;");:}
               ;//comnentamos el error de def var, porque era esta o lo de métodos, y a mi parecer es menos probable que aquí haya un error por haber colocado mal la visibilidad

def_tipo_variable ::= INT creacion_variable_numero                                          {:System.out.println("[S] estructura: def_tipoVar [INT]");
                                                                                              addTipoNumericoVars("int");:}
                    | DOUBLE creacion_variable_numero                                       {:System.out.println("[S] estructura: def_tipoVar [DOUBLE]");
                                                                                              addTipoNumericoVars("double");:}
                    | STRING creacion_variable_string                                       {:System.out.println("[S] estructura: def_tipoVar [STRING]");:}
                    | CHAR creacion_variable_char                                           {:System.out.println("[S] estructura: def_tipoVar [CHAR]");:}
                    | BOOLEAN creacion_variable_boolean                                     {:System.out.println("[S] estructura: def_tipoVar [BOOLEAN]");:}
                    | OBJECT creacion_variable_object                                       {:System.out.println("[S] estructura: def_tipoVar [OBJECT]");:}
                    | OBJETO:tipoObjeto creacion_variable_objeto                            {:System.out.println("[S] estructura: def_tipoVar [OBJETO_interno]");
                                                                                              addTipoObjetoVars(Token.parseToken(tipoObjeto).getLexema());:}
                    | NOMBRE:tipoObjeto creacion_variable_objeto                            {:System.out.println("[S] estructura: def_tipoVar [OBJETO_externo]");
                                                                                              addTipoObjetoVars(Token.parseToken(tipoObjeto).getLexema());:}
                    | error:err                                                             {:System.out.println("[S] error: VARIABLE CREATION EXPECTED <tipo> <list-vars>");
                                                                                              addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_VARIABLE_CREATION);:}
                    ;                    

creacion_variable_numero ::= creacion_variable_numero COMA variable_numero                       {:System.out.println("[S] substruct: creacion_var_numero: LISTA");:}
                           | variable_numero                                                     {:System.out.println("[S] substruct: creacion_var_numero: UNICA");:}
                           | error:err variable_numero                                           {:System.out.println("[S] error: BAD NUMBER VAR CREATION");
                                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_NUMBER_VAR_CREATION);:}
                           ;/*teríamos COMA, pero con ese no analizaba nada después del error, al menos con PC, ya analiza, un poco mucho tarde xD, pero al menos ya lo hace xD*/

variable_numero ::= NOMBRE:nombre IGUAL contenido_numero                       {:System.out.println("[S] substruct: variable_numero: con INI [cont_#]");
                                                                                 addInfoVariables(null, nombre);
                                                                                 numeroVarsNumericas++;:}
                  | NOMBRE:nombre IGUAL contenido_char                         {:System.out.println("[S] substruct: variable_numero: con INI [cont_C]");
                                                                                 addInfoVariables(null, nombre);
                                                                                 numeroVarsNumericas++;:}//aunque el contenido sea char, el tipo sigue siendo numérico...
                  | NOMBRE:nombre                                              {:System.out.println("[S] substruct: variable_numero: sin INI");
                                                                                 addInfoVariables(null, nombre);
                                                                                 numeroVarsNumericas++;:}
         //         | error                                               {:System.out.println("[S] error: EXPECTED NUMBER VAR DEFINITION <var> = <contenido [int|double|char|var]>; <var>");:}
                  ;/*contenido# puede devolver 1 nombre xD [y tb un#] por eso no add contenido_var*/

creacion_variable_string ::= creacion_variable_string COMA variable_string                          {:System.out.println("[S] substruct: creacion_var_string: LISTA");:}
                           | variable_string                                                        {:System.out.println("[S] substruct: creacion_var_string: UNICA");:}
                           | error:err variable_string                                              {:System.out.println("[S] error: BAD STRING VAR CREATION");
                                                                                                      addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_STRING_VAR_CREATION);:}
                           ;

variable_string ::= NOMBRE:nombre IGUAL contenido_variable                      {:System.out.println("[S] substruct: variable_string: con INI [cont_V]");
                                                                                  addInfoVariables("String", nombre);:}
                  | NOMBRE:nombre IGUAL contenido_string  /*contenido_string*/  {:System.out.println("[S] substruct: variable_string: con INI [cont_S]");
                                                                                  addInfoVariables("String", nombre);:}
                  | NOMBRE:nombre                                               {:System.out.println("[S] substruct: variable_string: sin INI");
                                                                                  addInfoVariables("String", nombre);:}
        //          | error                                                {:System.out.println("[S] error: EXPECTED STRING VAR DEFINITION <var> = <contenido [str|var]>; <var>");:}
                  /*con contenido_string me refería a la antigua versión de concat... en todo caso es concat xD, no esa antiguedad jaja*/
                  ;

creacion_variable_char ::= creacion_variable_char COMA variable_char                              {:System.out.println("[S] substruct: creacion_var_char: LISTA");:}
                         | variable_char                                                          {:System.out.println("[S] substruct: creacion_var_char: UNICA");:}
                         | error:err variable_char                                                {:System.out.println("[S] error: BAD CHAR VAR CREATION");
                                                                                                    addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_CHAR_VAR_CREATION);:}
                         ;

variable_char ::= NOMBRE:nombre IGUAL contenido_variable                         {:System.out.println("[S] substruct: variable_char: con INI [cont_V]");
                                                                                   addInfoVariables("char", nombre);:}
                | NOMBRE:nombre IGUAL contenido_char                             {:System.out.println("[S] substruct: variable_char: con INI [cont_C]");
                                                                                   addInfoVariables("char", nombre);:}
                | NOMBRE:nombre                                                  {:System.out.println("[S] substruct: variable_char: sin INI");
                                                                                   addInfoVariables("char", nombre);:}
        //        | error                                                   {:System.out.println("[S] error: EXPECTED CHAR VAR DEFINITION <ID> = <contenido [char|var]>; <ID>");:}
                ;/*igual que en def_metodo_char no coloqué contenido#, aquí tampoco porque puede generar variables y variables de enteros no aceptar y doubles ni en valor ni var, lo que permitiría add contenido-# y no dbeería es a los double, porque lo de la variable aún tendŕia que revisar xD si analizara sem xD*/

creacion_variable_boolean ::= creacion_variable_boolean COMA variable_boolean                      {:System.out.println("[S] substruct: creacion_var_boolean: LISTA");:}
                           | variable_boolean                                                      {:System.out.println("[S] substruct: creacion_var_boolean: UNICA");:}
                           | error:err variable_boolean                                            {:System.out.println("[S] error: BAD BOOLEAN VAR CREATION");
                                                                                                      addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_BOOLEAN_VAR_CREATION);:}
                           ;

variable_boolean ::= NOMBRE:nombre IGUAL contenido_variable                       {:System.out.println("[S] substruct: variable_boolean: con INI [cont_V]");
                                                                                    addInfoVariables("boolean", nombre);:}
                   | NOMBRE:nombre IGUAL contenido_boolean /*condiciones*/        {:System.out.println("[S] substruct: variable_boolean: con INI [cont_B]");
                                                                                    addInfoVariables("boolean", nombre);:}
                   | NOMBRE:nombre                                                {:System.out.println("[S] substruct: variable_boolean: sin Ini");
                                                                                    addInfoVariables("boolean", nombre);:}
        //           | error                                                {:System.out.println("[S] error: EXPECTED BOOLEAN VAR DEFINITION <ID> = <contenido [boolean|var]>; <ID>");:}
                   ;/*por si acaso da algún conflicto, deja solo booleans y contenido_negs, aunque no creo que vaya a haber*/

creacion_variable_object ::= creacion_variable_object COMA variable_object                       {:System.out.println("[S] substruct: creacion_var_object: LISTA");:}
                           | variable_object                                                     {:System.out.println("[S] substruct: creacion_var_object: UNICA");:}
                           | error:err variable_object                                           {:System.out.println("[S] error: BAD OBJECT VAR CREATION");
                                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_OBJECT_VAR_CREATION);:}
                           ;

variable_object ::= NOMBRE:nombre IGUAL contenido_variable                         {:System.out.println("[S] substruct: variable_object: con INI [cont_V]");
                                                                                     addInfoVariables("Object", nombre);:}
                  | NOMBRE:nombre IGUAL contenido_object                           {:System.out.println("[S] substruct: variable_object: con INI [cont_Oc]");
                                                                                     addInfoVariables("Object", nombre);:}
                  | NOMBRE:nombre IGUAL contenido_objeto                           {:System.out.println("[S] substruct: variable_object: con INI [cont_O]");
                                                                                     addInfoVariables("Object", nombre);:}
                  | NOMBRE:nombre                                                  {:System.out.println("[S] substruct: variable_object: sin Ini");
                                                                                     addInfoVariables("Object", nombre);:}
        //          | error                                                   {:System.out.println("[S] error: EXPECTED STRING VAR DEFINITION <ID> = <contenido [object|objeto|var]>; <ID>");:}
                  ;/*creo que ya no puse lo de string porque se me olvidó o porque vi algún conclicto... yo me acuerdo que si lo había peuesto xD*/                

creacion_variable_objeto ::= creacion_variable_objeto COMA variable_objeto                       {:System.out.println("[S] substruct: creacion_var_objetO: LISTA");:}
                           | variable_objeto                                                     {:System.out.println("[S] substruct: creacion_var_objetO: UNICA");:}
                           | error:err variable_objeto                                           {:System.out.println("[S] error: BAD CUSTOM OBJECT VAR CREATION");
                                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_CUSTOM_OBJECT_VAR_CREATION);:}
                           ;

variable_objeto ::= NOMBRE:nombre IGUAL contenido_variable                         {:System.out.println("[S] substruct: variable_objetO: con INI [cont_V");
                                                                                     addInfoVariables(null, nombre);
                                                                                     numeroVarsObjetoCreadas++;:}
                  | NOMBRE:nombre IGUAL contenido_objeto                           {:System.out.println("[S] substruct: variable_objetO: con INI [cont_O");
                                                                                     addInfoVariables(null, nombre);
                                                                                     numeroVarsObjetoCreadas++;:}
                  | NOMBRE:nombre                                                  {:System.out.println("[S] substruct: variable_objetO: sin Ini");
                                                                                     addInfoVariables(null, nombre);
                                                                                     numeroVarsObjetoCreadas++;:}
        //          | error                                                   {:System.out.println("[S] error: EXPECTED STRING VAR DEFINITION <ID> = <contenido [objeto|var]>; <ID>");:}
                  ;/*hay que ver lo de los paréntesis aquí y en los demás cotenidos... parentesis ;-;*/

def_metodo ::= visibilidad cuerpo_def_metodo                           {:System.out.println("[S] estructura: def_metodo [visible]");:}
             | cuerpo_def_metodo                                       {:System.out.println("[S] estructura: def_metodo [invisible]");:}
       //      | error:err                                               {:System.out.println("[S] error: BAD METHOD|CONSTRUCTOR DEFINITION");
       //                                                                  addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_METHOD_DECLARATION);:}
             ;//vamos a dejar la RP de error de cuerpo_def_metodo en lugar de esta, quedaríamos en una sit simi a lo que tenemos en var xD

cuerpo_def_metodo ::= def_metodo_constructor                           {:System.out.println("[S] substruct: cuerpo_def_metodo: def_metodo_constructor");:}
                    | def_metodo_tipo                                  {:System.out.println("[S] substruct: cuerpo_def_metodo: def_metodo_TIPO");:}
                    | def_metodo_void                                  {:System.out.println("[S] substruct: cuerpo_def_metodo: def_metodo_VOID");:}                    
                    | error:err                                        {:System.out.println("[S] error: METHOD CREATION EXPECTED constructor|method [INT, DOUBLE, STRING, BOOLEAN, CHAR|OBJECT|OBJETO|VOID]");
                                                                         addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_METHOD_BODY_DECLARATION);:}
                    ;

def_metodo_constructor ::= OBJETO:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_constructor                     {:System.out.println("[S] substruct: def_metodo_constructor");
                                                                                                                              addInfoMetodo("constructor", nombre);:}//por ser constructor, aquí su nombre es el lex del Objeto
                         ;

cuerpo_metodo_constructor ::= LLAVE_A bloque LLAVE_C                              {:System.out.println("[S] substruct: no_void [cuerpo_cnstrct [CB]]");:}
                            | LLAVE_A LLAVE_C                                     {:System.out.println("[S] substruct: no_void [cuerpo_cnstrct [SB]]");:}    
                            | error:err LLAVE_C                                   {:System.out.println("[S] error: NO CONSTRUCTOR BODY DEFINED");
                                                                                    addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_CONSTRUCTOR_BODY_DECLARATION);:}
                            ;

def_metodo_tipo ::= INT NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_numero                              {:System.out.println("[S] substruct: def_metodo_tipo: INT");
                                                                                                                               addInfoMetodo("int", nombre);:}
                  | DOUBLE NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_numero                           {:System.out.println("[S] substruct: def_metodo_tipo: DOUBLE");
                                                                                                                               addInfoMetodo("double", nombre);:}
                  | STRING NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_string                           {:System.out.println("[S] substruct: def_metodo_tipo: STRING");
                                                                                                                               addInfoMetodo("String", nombre);:}
                  | CHAR NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_char                               {:System.out.println("[S] substruct: def_metodo_tipo: CHAR");
                                                                                                                               addInfoMetodo("char", nombre);:}
                  | BOOLEAN NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_boolean                         {:System.out.println("[S] substruct: def_metodo_tipo: BOOLEAN");
                                                                                                                               addInfoMetodo("boolean", nombre);:}
                  | OBJECT NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_object                           {:System.out.println("[S] substruct: def_metodo_tipo: OBJECT");
                                                                                                                               addInfoMetodo("Object", nombre);:}
                  | OBJETO:tipoObjeto NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_objeto                {:System.out.println("[S] substruct: def_metodo_tipo: OBJETO_interno");
                                                                                                                               addInfoMetodo(Token.parseToken(tipoObjeto).getLexema(), nombre);:}
                  | NOMBRE:tipoObjeto NOMBRE:nombre PARENTESIS_A parametros PARENTESIS_C cuerpo_metodo_objeto                {:System.out.println("[S] substruct: def_metodo_tipo: OBJETO_externo");
                                                                                                                               addInfoMetodo(Token.parseToken(tipoObjeto).getLexema(), nombre);:}
          //        | error                                                                                             {:System.out.println("[S] error: METHOD CREATION EXPECTED <tipo> ( <param-list> ) { body|e }");:}
                  ;

cuerpo_metodo_numero ::= LLAVE_A bloque retorno_numero LLAVE_C                                                               {:System.out.println("[S] substruct: cuerpo_metodo_# [CB, CR_#]");:}            
                       | LLAVE_A retorno_numero LLAVE_C                                                                      {:System.out.println("[S] substruct: cuerpo_metodo_# [SB, CR_#]");:}                                               
                       | LLAVE_A bloque retorno_char LLAVE_C                                                                 {:System.out.println("[S] substruct: cuerpo_metodo_# [CB, CR_C]");:}            
                       | LLAVE_A retorno_char LLAVE_C                                                                        {:System.out.println("[S] substruct: cuerpo_metodo_# [SB, CR_C]");:}                        
                       | LLAVE_A bloque RETURN THIS PUNTO cuerpo_invocacion_var PUNTO_COMA LLAVE_C                           {:System.out.println("[S] substruct: cuerpo_metodo_# [CB, CR_IV]");:}                    
                       | LLAVE_A RETURN THIS PUNTO cuerpo_invocacion_var PUNTO_COMA LLAVE_C                                  {:System.out.println("[S] substruct: cuerpo_metodo_# [SB, CR_IV]");:}                                               
                       | LLAVE_A bloque RETURN NOMBRE PUNTO cuerpo_invocacion_var PUNTO_COMA LLAVE_C                         {:System.out.println("[S] substruct: cuerpo_metodo_# [CB, CR_IV]");:}            
                       | LLAVE_A RETURN NOMBRE PUNTO cuerpo_invocacion_var PUNTO_COMA LLAVE_C                                {:System.out.println("[S] substruct: cuerpo_metodo_# [SB, CR_IV]");:}                        
                       | LLAVE_A bloque RETURN THIS PUNTO cuerpo_invocacion_metodo PUNTO_COMA LLAVE_C                        {:System.out.println("[S] substruct: cuerpo_metodo_# [CB, CR_IM]");:}            
                       | LLAVE_A RETURN THIS PUNTO cuerpo_invocacion_metodo PUNTO_COMA LLAVE_C                               {:System.out.println("[S] substruct: cuerpo_metodo_# [SB, CR_IM]");:}                                               
                       | LLAVE_A bloque RETURN cuerpo_invocacion_metodo PUNTO_COMA LLAVE_C                                   {:System.out.println("[S] substruct: cuerpo_metodo_# [CB, CR_IM]");:}            
                       | LLAVE_A RETURN cuerpo_invocacion_metodo PUNTO_COMA LLAVE_C                                          {:System.out.println("[S] substruct: cuerpo_metodo_# [SB, CR_IM]");:}                        
                       /*estos últimos dos puesto que ambos permiten devolver char... lo de double no permitido en int lo debería revisar sem sea que se coloque a éstos últimos o no xD*/
                       | error:err LLAVE_C                                                                                   {:System.out.println("[S] error: BAD DEFINITION OF NUMBER [INT|DOUBLE] METHOD BODY");
                                                                                                                               addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_NUMBER_BODY_DECLARATION);:}
                       ;

cuerpo_metodo_string ::= LLAVE_A bloque retorno_variable LLAVE_C                     {:System.out.println("[S] substruct: cuerpo_metodo_string [CB, CR_var]");:}
                       | LLAVE_A retorno_variable LLAVE_C                            {:System.out.println("[S] substruct: cuerpo_metodo_string [SB, CR_var]");:}
                       | LLAVE_A bloque retorno_string LLAVE_C                       {:System.out.println("[S] substruct: cuerpo_metodo_string [CB, CR_S]");:}
                       | LLAVE_A retorno_string LLAVE_C                              {:System.out.println("[S] substruct: cuerpo_metodo_string [SB, CR_S]");:}
                       | error:err LLAVE_C                                           {:System.out.println("[S] error: BAD DEFINITION STRING OF METHOD BODY");
                                                                                       addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_STRING_BODY_DECLARATION);:}
                       ;

cuerpo_metodo_char ::= LLAVE_A bloque retorno_variable LLAVE_C                   {:System.out.println("[S] substruct: cuerpo_metodo_char [CB, CR_var]");:}
                     | LLAVE_A retorno_variable LLAVE_C                          {:System.out.println("[S] substruct: cuerpo_metodo_char [SB, CR_var]");:}
                     | LLAVE_A bloque retorno_char LLAVE_C                       {:System.out.println("[S] substruct: cuerpo_metodo_char [CB, CR_C]");:}
                     | LLAVE_A retorno_char LLAVE_C                              {:System.out.println("[S] substruct: cuerpo_metodo_char [SB, CR_C]");:} 
                     | error:err LLAVE_C                                         {:System.out.println("[S] error: BAD DEFINITION CHAR OF METHOD BODY");
                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_CHAR_BODY_DECLARATION);:}                 
                     ;/*aquí si no voy a colocar que puede deolver# porque tb estaría permitiendo retornar doubles...                  */
                
cuerpo_metodo_boolean ::= LLAVE_A bloque retorno_variable LLAVE_C                {:System.out.println("[S] substruct: cuerpo_metodo_char [CB, CR_var]");:}
                        | LLAVE_A retorno_variable LLAVE_C                       {:System.out.println("[S] substruct: cuerpo_metodo_char [SB, CR_var]");:}
                        | LLAVE_A bloque retorno_boolean LLAVE_C                 {:System.out.println("[S] substruct: cuerpo_metodo_char [CB, CR_B]");:}
                        | LLAVE_A retorno_boolean LLAVE_C                        {:System.out.println("[S] substruct: cuerpo_metodo_char [SB, CR_B]");:}
                        | error:err LLAVE_C                                      {:System.out.println("[S] error: BAD DEFINITION OF BOOLEAN METHOD BODY");
                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_BOOLEAN_BODY_DECLARATION);:}
                        ;

cuerpo_metodo_object ::= LLAVE_A bloque retorno_variable LLAVE_C                 {:System.out.println("[S] substruct: cuerpo_metodo_object [CB, CR_var]");:}
                       | LLAVE_A retorno_variable LLAVE_C                        {:System.out.println("[S] substruct: cuerpo_metodo_object [SB, CR_var]");:}
                       | LLAVE_A bloque retorno_object LLAVE_C                   {:System.out.println("[S] substruct: cuerpo_metodo_object [CB, CR_OC]");:}
                       | LLAVE_A retorno_object LLAVE_C                          {:System.out.println("[S] substruct: cuerpo_metodo_object [SB, CR_OC]");:}
                       | LLAVE_A bloque retorno_objeto LLAVE_C                   {:System.out.println("[S] substruct: cuerpo_metodo_object [CB, CR_O]");:}
                       | LLAVE_A retorno_objeto LLAVE_C                          {:System.out.println("[S] substruct: cuerpo_metodo_object [SB, CR_O]");:}
                       | LLAVE_A bloque retorno_string LLAVE_C                   {:System.out.println("[S] substruct: cuerpo_metodo_object [CB, CR_S]");:}
                       | LLAVE_A retorno_string LLAVE_C                          {:System.out.println("[S] substruct: cuerpo_metodo_object [SB, CR_S]");:}
                       | error:err LLAVE_C                                       {:System.out.println("[S] error: BAD DEFINITION OF OBJECT METHOD BODY");
                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_OBJECT_BODY_DECLARATION);:}
                       /*Si los ultimos 4 [los de string más que los de objeto] dan conflictos, auqneu yo creería que no, quítalos xD, puest el caso normal y que esperarían ya lo tienes xD*/
                       ;

cuerpo_metodo_objeto ::= LLAVE_A bloque retorno_variable LLAVE_C                  {:System.out.println("[S] substruct: cuerpo_metodo_objeto [CB, CR_var]");:}
                       | LLAVE_A retorno_variable LLAVE_C                         {:System.out.println("[S] substruct: cuerpo_metodo_objeto [SB, CR_var]");:}
                       | LLAVE_A bloque retorno_objeto LLAVE_C                    {:System.out.println("[S] substruct: cuerpo_metodo_objeto [CB, CR_O]");:}
                       | LLAVE_A retorno_objeto LLAVE_C                           {:System.out.println("[S] substruct: cuerpo_metodo_objeto [SB, CR_O]");:}                                              
                       | error:err LLAVE_C                                        {:System.out.println("[S] error: BAD DEFINITION OF CUSTOM OBJECT METHOD BODY");
                                                                                    addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_OBJETO_BODY_DECLARATION);:}
                       ;

def_metodo_void ::= VOID NOMBRE:nombre cuerpo_metodo_void                         {:System.out.println("[S] substruct: cuerpo_def_metodo: def_metodo_VOID");
                                                                                      addInfoMetodo("void", nombre);:}                    
                  ;

cuerpo_metodo_void ::= PARENTESIS_A parametros PARENTESIS_C LLAVE_A bloque RETURN PUNTO_COMA LLAVE_C                       {:System.out.println("[S] substruct: def_metodo_void [CB, CR]");:}
                     | PARENTESIS_A parametros PARENTESIS_C LLAVE_A bloque LLAVE_C                                         {:System.out.println("[S] substruct: def_metodo_void [CB, SR]");:}             
                     | PARENTESIS_A parametros PARENTESIS_C LLAVE_A RETURN PUNTO_COMA LLAVE_C                              {:System.out.println("[S] substruct: def_metodo_void [SB, CR]");:}
                     | PARENTESIS_A parametros PARENTESIS_C LLAVE_A LLAVE_C                                                {:System.out.println("[S] substruct: def_metodo_void [SB, SR]");:}
                     | error:err LLAVE_C                                                                                   {:System.out.println("[S] error: BAD DEFINITION OF VOID METHOD BODY");
                                                                                                                             addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_VOID_BODY_DECLARATION);:}
                     ;/*deplano que le vamos a dejar la Llave_C... porque si se la quito observé con lo de {{ que sigue diciendo que hay error después con la invoc de vars...*/

parametros ::= parametros COMA parametro                               {:System.out.println("[S] substruct: parametros: LISTA");:}
             | parametro                                               {:System.out.println("[S] substruct: parametros: UNICO");:}
             |                                                         {:System.out.println("[S] substruct: parametros: ninguno");:}/*a menos que tb lo llame como forma de finalizar la lista, aunque yo pienso que no debería xD*/
             | error:err                                               {:System.out.println("[S] error: PARAM OR LIST OF THEM WITH ERRORS");
                                                                         addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_PARAM_LIST);:}
             ;

parametro ::= tipo:tipo NOMBRE:nombre                                  {:System.out.println("[S] substruct: parametro");
                                                                         listaParametros.add(new Variable(tipo,Token.parseToken(nombre).getLexema()));
                                                                         addInfoVariables(tipo, nombre);:}//si en dado caso surgiera un error con el tipo, aquí se recibiría null, o eso pienso...
        //    | error                                                    {:System.out.println("[S] error: EXPECT PARAM STRUCT <tipo> <identifier>");:}
            ;

tipo ::= INT                            {:System.out.println("[S] tipo: INT");
                                          RESULT = "int";:}
       | DOUBLE                         {:System.out.println("[S] tipo: DOUBLE");
                                          RESULT = "double";:}
       | STRING                         {:System.out.println("[S] tipo: STRING");
                                          RESULT = "String";:}
       | CHAR                           {:System.out.println("[S] tipo: CHAR");
                                          RESULT = "char";:}
       | BOOLEAN                        {:System.out.println("[S] tipo: BOOLEAN");
                                          RESULT = "boolean";:}
       | OBJECT                         {:System.out.println("[S] tipo: OBJECT");
                                          RESULT = "Object";:}
       | OBJETO:objeto                  {:System.out.println("[S] tipo: OBJETO_interno");
                                          RESULT = (Token.parseToken(objeto).getLexema());:}
       | NOMBRE:objeto                  {:System.out.println("[S] tipo: OBJETO_externo");
                                          RESULT = (Token.parseToken(objeto).getLexema());:}
    //   | error                          {:System.out.println("[S] error: TYPE [int|doouble|String|char|boolean|Object|<CUSTOM OBJECT>] EXPECTED");:}
       ;/*ya reemplacé por lo de objeto xD xD*/

bloque ::= bloque sentencias                            {:System.out.println("[S] bloque: +1 sentencia");:}
         | sentencias                                   {:System.out.println("[S] bloque: 1 sentencia");:}
     //    | error                                        {:System.out.println("[S] error: BAD METHOD or STATEMENT BODY");:}
         ;

sentencias ::= def_variable                                {:System.out.println("[S] sentencias bloque: def_var");:}//lo las vars, debes setearlo cuando se cree el obj de Método, porque aquí no hay forma que sepas el nombre del método... porque la axn del método se exe hasta el fina... [mira NetBeans..]
             | asignacion                                  {:System.out.println("[S] sentencias bloque: asignacion");:}
          //   | asignacion_multiple
             | ciclo                                       {:System.out.println("[S] sentencias bloque: ciclo");:}
             | invocacion                                  {:System.out.println("[S] sentencias bloque: invocacion");:}
             | sentencia_control                           {:System.out.println("[S] sentencias bloque: sentencia_control");:}
             | operacion_unaria PUNTO_COMA                 {:System.out.println("[S] sentencias bloque: operacion_unaria");:}
         //    | error                                       {:System.out.println("[S] error: STATEMENT [var def|assignment|cicle|invocation|control|unary operation] EXPECTED");:}
             ;

asignacion ::= cuerpo_invocacion_var IGUAL tipos_asignacion PUNTO_COMA                                  {:System.out.println("[S] estructura: asignacion");:}
             | THIS PUNTO cuerpo_invocacion_var IGUAL tipos_asignacion PUNTO_COMA                       {:System.out.println("[S] estructura: asignacion");:}
            // | cuerpo_invocacion_metodo IGUAL tipos_asignacion PUNTO_COMA                          {:System.out.println("[S] estructura: asignacion");:}
            // | THIS cuerpo_invocacion_metodo IGUAL tipos_asignacion PUNTO_COMA                       {:System.out.println("[S] estructura: asignacion");:}
        //     | error                                                                                    {:System.out.println("[S] error: BAD ASSIGNMENT");:}
             ;//yo me recordaba que se puede asignar a un método get, porque el inge Moi lo hizo, pero no me sale al probar en ajva :v xD

tipos_asignacion ::= contenido_numero                                            {:System.out.println("[S] substruct: tipos_asig: cont_#");:}
                   | contenido_string                                            {:System.out.println("[S] substruct: tipos_asig: cont_S");:}
                   /*si me dan conflicto cont# y contS, entonces agregaré numeros y contenido variable, porque eli cont#, pues val# sería generado por contS [según lo que diría el msje].. lo malo es que no lo genera completamente sino solo las sumas... en todo caso lo que tendría que hacer es dejar solo strings, puesto que es menos probable que ad*/
                   | contenido_char                                              {:System.out.println("[S] substruct: tipo_asig: cont_C");:} 
                   | contenido_boolean                                           {:System.out.println("[S] substruct: tipo_asig: cont_B");:}  
                   | contenido_object                                            {:System.out.println("[S] substruct: tipo_asig: cont_Oc");:}
                   | contenido_objeto                                            {:System.out.println("[S] substruct: tipo_asig: cont_O");:}
                   | NOMBRE PUNTO cuerpo_invocacion_var                          {:System.out.println("[S] substruct: tipo_asig: IV");:}  //no por los conflictos que se generan con cont_#...
                   | THIS PUNTO cuerpo_invocacion_var                            {:System.out.println("[S] substruct: tipo_asig: THIS. IV");:}
                   | cuerpo_invocacion_metodo                                    {:System.out.println("[S] substruct: tipo_asig: IM");:}
                   | THIS PUNTO cuerpo_invocacion_metodo                         {:System.out.println("[S] substruct: tipo_asig: THIS. IM");:}
                   /*contenido_variable//no pongo cont_var puesto que contenido# permite esto porque devuelve 1 nombre [y tb numero, pero en este caso interesa más lo de nombre xD]*/
                   | error:err                                                   {:System.out.println("[S] error: BAD ASSIGNED CONTENT");
                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_ASSGINED_CONTENT);:}
                   ;

/*asignacion_multiple ::= contenido_asignacion_multiple tipos_asignacion PUNTO_COMA
                      ;

contenido_asignacion_multiple ::= asignacion_multiple IGUAL 
                                | cuerpo_invocacion_var
                                | THIS PUNTO cuerpo_invocacion_var
                                ;*///provcoca conflictos, por la repitencia de los cuerpos de invocación...

contenido_variable ::= PARENTESIS_A contenido_variable PARENTESIS_C                               {:System.out.println("[S] substruct: cont_var: ( cont_var )");:}
                     | THIS PUNTO cuerpo_invocacion_var                                           {:System.out.println("[S] substruct: cont_var: THIS . IV");:}
                     | cuerpo_invocacion_var                                                      {:System.out.println("[S] substruct: cont_var: ( IV )");:}   
                     | cuerpo_invocacion_metodo                                                   {:System.out.println("[S] substruct: cont_var: IM");:}
                     | THIS PUNTO cuerpo_invocacion_metodo                                        {:System.out.println("[S] substruct: cont_var: THIS . IM");:}
       //              | error                                                                 {:System.out.println("[S] error: VARIABLE TYPE CONTENT STRUCT EXPECTED");:}
                     ;

contenido_numero ::= contenido_numero MAS contenido_numero                            {:System.out.println("[S] substruct: cont_#: MAS");:}
                  | contenido_numero RESTA contenido_numero                           {:System.out.println("[S] substruct: cont_#: RESTA");:}
                  | contenido_numero ASTERISCO contenido_numero                       {:System.out.println("[S] substruct: cont_#: ASTERISCO");:}
                  | contenido_numero DIV contenido_numero                             {:System.out.println("[S] substruct: cont_#: DIV");:}
                  | RESTA contenido_numero                                            {:System.out.println("[S] substruct: cont_#: MENOS");:}
                  %prec MENOS                                        
                  | PARENTESIS_A contenido_numero PARENTESIS_C                        {:System.out.println("[S] substruct: cont_#: ( cont_# )");:}
                  | NUMERO                                                            {:System.out.println("[S] substruct: cont_#: NUMERO");:}
                  | NOMBRE                                                            {:System.out.println("[S] substruct: cont_#: NOMBRE [var]");:}
           //       | error                                                             {:System.out.println("[S] error: NUMERICAL TYPE CONTENT STRUCT EXPECTED");:}
                  ;

contenido_string ::= contenido_boolean MAS cualquier_contenido                                  {:System.out.println("[S] substruct: cont_S [ cont_boolean + cc ]");:}
                   | permitidos                                                                 {:System.out.println("[S] substruct: cont_S [ permitidos ]");:}
         //          | error                                                                      {:System.out.println("[S] error: STRING TYPE CONTENT STRUCT EXPECTED");:}
                   ;

permitidos ::= contenido_numero MAS permitidos                                      {:System.out.println("[S] substruct: permitidos [cont_# + permitidos]");:} 
             | contenido_char MAS permitidos                                        {:System.out.println("[S] substruct: permitidos [cont_C + permitidos]");:}
             | cualquier_contenido                                                  {:System.out.println("[S] substruct: permitidos [cc]");:}
      //       | error                                                                {:System.out.println("[S] error: NO TYPE OF CONCATENATION ALLOWED");:}
             ;

cualquier_contenido ::= cualquier_contenido opciones_cualquier_contenido                                    {:System.out.println("[S] substruct: cualq_cont: [cc o_cc]");:}
                      | strings                                                                             {:System.out.println("[S] substruct: cualq_cont: [strings]");:}
        //              | error                                                                               {:System.out.println("[S] error: CONCATENATION MALFORMED");:}
                      ;

opciones_cualquier_contenido ::= MAS contenido_numero                                {:System.out.println("[S] substruct: op_cc: [+ cont_#]");:}
                               | MAS contenido_char                                  {:System.out.println("[S] substruct: op_cc: [+ cont_C]");:}
                               | MAS contenido_boolean                               {:System.out.println("[S] substruct: op_cc: [+ cont_B]");:} 
                               | MAS strings                                         {:System.out.println("[S] substruct: op_cc: [+ strings]");:}
          //                     | error                                               {:System.out.println("[S] error: INVALID CONCATENATED CONTENT");:}
                               ;/*forma 1*/

strings ::= PARENTESIS_A strings PARENTESIS_C                           {:System.out.println("[S] substruct: strings: ( strings )");:}                   
         | CADENA                                                       {:System.out.println("[S] substruct: strings: CADENA");:}
    //     | error                                                        {:System.out.println("[S] error: STRING EXPECTED");:}
         ;

contenido_char ::= PARENTESIS_A contenido_char PARENTESIS_C                                 {:System.out.println("[S] substruct: cont_C: ( cont_C )");:}
                 | CARACTER                                                                 {:System.out.println("[S] substruct: cont_C: CARACTER");:}
          //       | error                                                                    {:System.out.println("[S] error: CHARACTER EXPECTED");:}
                 ;

contenido_object ::= PARENTESIS_A contenido_object PARENTESIS_C                             {:System.out.println("[S] substruct: cont_Oc: ( cont_Oc )");:}
                   | NEW OBJECT PARENTESIS_A PARENTESIS_C                                   {:System.out.println("[S] substruct: cont_Oc: NEW Oc()");:}
                   /*object no tiene parámetros, por lo tanto no recibe argus...*/
           //        | error                                                                  {:System.out.println("[S] error: OBJECT INSTANTATION EXPECTED");:}
                   ;

contenido_objeto ::= PARENTESIS_A contenido_objeto PARENTESIS_C                              {:System.out.println("[S] substruct: cont_O: ( cont_O )");:}
                   | NEW OBJETO PARENTESIS_A argumentacion PARENTESIS_C                      {:System.out.println("[S] substruct: cont_O: NEW O( argucion )");:}
                   | NEW NOMBRE PARENTESIS_A argumentacion PARENTESIS_C                      {:System.out.println("[S] substruct: cont_O: NEW NOMBRE( argucion )");:}
          //         | error                                                                   {:System.out.println("[S] error: CUSTOM OBJECT INSTANTATION EXPECTED");:}
                   ;

operacion_unaria ::= incremento                                 {:System.out.println("[S] substruct: op_unaria: INCRE");:}
                   | autoincremento                             {:System.out.println("[S] substruct: op_unaria: AUTO_INCRE");:}
           //        | error                                      {:System.out.println("[S] error: UNARY OPERATION [increment| autoincrement] MALF0RMED");:}
                   ;

incremento ::= NOMBRE MAS MAS                                                           {:System.out.println("[S] substruct: incre: NOMBRE ++");:}
             | THIS PUNTO cuerpo_invocacion_var MAS MAS                                 {:System.out.println("[S] substruct: incre: THIS . IV ++");:}
             | NOMBRE PUNTO cuerpo_invocacion_var MAS MAS                               {:System.out.println("[S] substruct: incre: NOMBRE . IV ++");:}
             | NOMBRE RESTA RESTA                                                       {:System.out.println("[S] substruct: incre: NOMBRE --");:}
             | THIS PUNTO cuerpo_invocacion_var RESTA RESTA                             {:System.out.println("[S] substruct: incre: THIS . IV --");:}
             | NOMBRE PUNTO cuerpo_invocacion_var RESTA RESTA                           {:System.out.println("[S] substruct: incre: NOMBRE . IV --");:}
             | MAS MAS NOMBRE                                                           {:System.out.println("[S] substruct: incre: ++ NOMBRE");:}
             | MAS MAS THIS PUNTO cuerpo_invocacion_var                                 {:System.out.println("[S] substruct: incre: ++ THIS . IV");:}
             | MAS MAS NOMBRE PUNTO cuerpo_invocacion_var                               {:System.out.println("[S] substruct: incre: ++ NOMBRE . IV");:}
             | RESTA RESTA NOMBRE                                                       {:System.out.println("[S] substruct: incre: -- NOMBRE");:}
             | RESTA RESTA THIS PUNTO cuerpo_invocacion_var                             {:System.out.println("[S] substruct: incre: -- THIS . IV");:}
             | RESTA RESTA NOMBRE PUNTO cuerpo_invocacion_var                           {:System.out.println("[S] substruct: incre: -- NOMBRE . IV");:}
    //         | error                                        {:System.out.println("[S] error: EXPECTED A TYPE OF INCEMENT [<var> <++|-->; <++|--> <var>");:}
             ;

autoincremento ::= THIS PUNTO cuerpo_invocacion_var opciones_autoincremento                                 {:System.out.println("[S] substruct: autoincre: THIS . IV ops_autoi");:}
                 | NOMBRE PUNTO cuerpo_invocacion_var opciones_autoincremento                               {:System.out.println("[S] substruct: autoincre: NOMBRE . IV ops_autoi");:}
                 | NOMBRE opciones_autoincremento                                                           {:System.out.println("[S] substruct: autoincre: NOMBRE ops_autoi");:}
    //             | error                                                          {:System.out.println("[S] error: AUTOINCREMENT EXPECTD");:}
                 ;

opciones_autoincremento ::= opciones_autoIncreMas                                 {:System.out.println("[S] substruct: ops_autoincre: +=");:}
                          | RESTA IGUAL contenido_numero                          {:System.out.println("[S] substruct: ops_autoincre: -=");:}
                          | ASTERISCO IGUAL contenido_numero                      {:System.out.println("[S] substruct: ops_autoincre: *=");:}
                          | DIV IGUAL contenido_numero                            {:System.out.println("[S] substruct: ops_autoincre: /=");:}
    //                      | error                                                 {:System.out.println("[S] error: EXPECTED A TYPE OF AUTOINCEMENT CONTENT [+= <NUMBER|STRING>; -= <NUMBER>; *= <NUMBER>; /= <NUMBER>");:}
                          ;

opciones_autoIncreMas ::= MAS IGUAL contenido_numero/*_X_*/                             {:System.out.println("[S] substruct: autoincre: += [cont_#]");:}
                        /*si da conflicto, entonces giual que en asignación, dejarásn ContS, eli cont#, add numeros y contenido variable, NO porque así evitaría las operaciones...*/
                        /* entonces en todo caso solo deja contenido_numero y cadena aunque en realidad se puede usar concat...*/
                        | MAS IGUAL contenido_string                                    {:System.out.println("[S] substruct: autoincre: += [cont_S]");:}
                        | MAS IGUAL THIS PUNTO cuerpo_invocacion_var                    {:System.out.println("[S] substruct: autoincre: += [THIS . IV]");:}
                        | MAS IGUAL NOMBRE PUNTO cuerpo_invocacion_var                  {:System.out.println("[S] substruct: autoincre: += [NOMBRE . IV]");:}
                        | MAS IGUAL THIS PUNTO cuerpo_invocacion_metodo                 {:System.out.println("[S] substruct: autoincre: += [THIS . IM]");:}
                        | MAS IGUAL cuerpo_invocacion_metodo                            {:System.out.println("[S] substruct: autoincre: += [IM]");:}
                        | error:err                                                     {:System.out.println("[S] error: += ONLY IS APLICABE TO STRINGs AND NUMBERs");
                                                                                          addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_AUTINCREMENT_CONTENT);:}
                        ;

ciclo ::= ciclo_for                                                                                                  {:System.out.println("[S] substruct: ciclo: FOR");:}
        | WHILE PARENTESIS_A contenido_boolean PARENTESIS_C cuerpo_estructuras                                       {:System.out.println("[S] substruct: ciclo: WHILE [cont_boolean]");:}        
        | WHILE PARENTESIS_A contenido_variable PARENTESIS_C cuerpo_estructuras                                      {:System.out.println("[S] substruct: ciclo: WHILE [cont_V]");:}        
        | DO cuerpo_estructuras WHILE PARENTESIS_A contenido_boolean PARENTESIS_C PUNTO_COMA                         {:System.out.println("[S] substruct: ciclo: DO-WHILE [cont_boolean]");:}        
        | DO cuerpo_estructuras WHILE PARENTESIS_A contenido_variable PARENTESIS_C PUNTO_COMA                        {:System.out.println("[S] substruct: ciclo: DO-WHILE [cont_V] ");:}        
        | error:err PARENTESIS_C                                                                                     {:System.out.println("[S] error: LOOP [FOR|WHILE|DO WHILE] MALFORMED");
                                                                                                                       addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_LOOP_STRUCT);:}
        ;

ciclo_for ::= FOR PARENTESIS_A asignacion_for condiciones_for incremento_for PARENTESIS_C cuerpo_estructuras                         {:System.out.println("[S] substruct: ciclo_for");:}            
    //        | error                                                                                                                  {:System.out.println("[S] error: BAD STRUCT OF \"FOR\" LOOP");:}
            ;

asignacion_for ::= asignacion_completa_for                                                     {:System.out.println("[S] substruct: ciclo_for: asignacion [completa]");:}
                 | asignacion                                                                  {:System.out.println("[S] substruct: ciclo_for: asignacion [parcial]");:}
                 /*puesto que permite que se add vars de todos los tipos de la práctica xD, e imagino que en realidad permite la de todos :0 xD*/
                 | PUNTO_COMA                                                                  {:System.out.println("[S] substruct: ciclo_for: asignacion [ninguna]");:}
                 | error:err PUNTO_COMA                                                        {:System.out.println("[S] error: \"FOR\" ASSIGNATION MALFORMED");
                                                                                                 addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_FOR_ASSIGNATION);:}
                 ;

asignacion_completa_for ::= INT NOMBRE:nombre IGUAL contenido_numero PUNTO_COMA                      {:System.out.println("[S] substruct: ciclo_for: asignacion_C [INT]");
                                                                                                       addInfoVariables("int", nombre);:}
                          | DOUBLE NOMBRE:nombre IGUAL contenido_numero PUNTO_COMA                   {:System.out.println("[S] substruct: ciclo_for: asignacion_C [DOUBLE]");
                                                                                                       addInfoVariables("double", nombre);:}
                          | STRING NOMBRE:nombre IGUAL contenido_string PUNTO_COMA                   {:System.out.println("[S] substruct: ciclo_for: asignacion_C [STRING-CS]");
                                                                                                       addInfoVariables("String", nombre);:}
                          | STRING NOMBRE:nombre IGUAL contenido_variable PUNTO_COMA                 {:System.out.println("[S] substruct: ciclo_for: asignacion_C [STRING-CV]");
                                                                                                       addInfoVariables("String", nombre);:}
                          | CHAR NOMBRE:nombre IGUAL contenido_char PUNTO_COMA                       {:System.out.println("[S] substruct: ciclo_for: asignacion_C [CHAR-CC]");
                                                                                                       addInfoVariables("char", nombre);:}
                          | CHAR NOMBRE:nombre IGUAL contenido_variable PUNTO_COMA                   {:System.out.println("[S] substruct: ciclo_for: asignacion_C [CHAR-CV]");
                                                                                                       addInfoVariables("char", nombre);:}
                          | BOOLEAN NOMBRE:nombre IGUAL contenido_boolean PUNTO_COMA                 {:System.out.println("[S] substruct: ciclo_for: asignacion_C [BOOLEAN-CB]");
                                                                                                       addInfoVariables("boolean", nombre);:}
                          | BOOLEAN NOMBRE:nombre IGUAL contenido_variable PUNTO_COMA                {:System.out.println("[S] substruct: ciclo_for: asignacion_C [BOOLEAN-CV]");
                                                                                                       addInfoVariables("boolean", nombre);:}
                          | OBJECT NOMBRE:nombre IGUAL contenido_object PUNTO_COMA                   {:System.out.println("[S] substruct: ciclo_for: asignacion_C [OBJECT-COc]");
                                                                                                       addInfoVariables("Object", nombre);:}
                          | OBJECT NOMBRE:nombre IGUAL contenido_variable PUNTO_COMA                 {:System.out.println("[S] substruct: ciclo_for: asignacion_C [OBJETC-CV]");
                                                                                                       addInfoVariables("Object", nombre);:}
                          | OBJETO:tipoObjeto NOMBRE:nombre IGUAL contenido_objeto PUNTO_COMA        {:System.out.println("[S] substruct: ciclo_for: asignacion_C [OBJETO_interno-CO]");
                                                                                                       addInfoVariables(Token.parseToken(tipoObjeto).getLexema(), nombre);:}
                          | OBJETO:tipoObjeto NOMBRE:nombre IGUAL contenido_variable PUNTO_COMA      {:System.out.println("[S] substruct: ciclo_for: asignacion_C [OBJETO_interno-CV]");
                                                                                                       addInfoVariables(Token.parseToken(tipoObjeto).getLexema(), nombre);:}
                          | NOMBRE:tipoObjeto NOMBRE:nombre IGUAL contenido_objeto PUNTO_COMA        {:System.out.println("[S] substruct: ciclo_for: asignacion_C [OBJETO_externo-CO]");
                                                                                                       addInfoVariables(Token.parseToken(tipoObjeto).getLexema(), nombre);:}
                          | NOMBRE:tipoObjeto NOMBRE:nombre IGUAL contenido_variable PUNTO_COMA      {:System.out.println("[S] substruct: ciclo_for: asignacion_C [OBJETO_externo-CV]");
                                                                                                       addInfoVariables(Token.parseToken(tipoObjeto).getLexema(), nombre);:}
                //          | error                                                             {:System.out.println("[S] error: FULL ASSIGNMENT EXPECTED");:}
                          ;/*solo donde hay cont# no porque ese por sí solo permite el cont_var xD*/

condiciones_for ::= contenido_boolean PUNTO_COMA                                 {:System.out.println("[S] substruct: ciclo_for: condiciones [existente]");:}
                  | contenido_variable PUNTO_COMA                                {:System.out.println("[S] substruct: ciclo_for: condiciones [cont_V]");:}
                  | PUNTO_COMA                                                   {:System.out.println("[S] substruct: ciclo_for: condiciones [ninguna]");:}
                  | error:err PUNTO_COMA                                         {:System.out.println("[S] error: \"FOR\" CONDITIONS MALFORMED");
                                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_FOR_CONDITION);:}
                  ;

incremento_for ::= operacion_unaria                              {:System.out.println("[S] substruct: ciclo_for: incremento [existente]");:}
                 |                                               {:System.out.println("[S] substruct: ciclo_for: incremento [ninguna]");:}
                 | error:err                                     {:System.out.println("[S] error: \"FOR\" INCREMENT MALFORMED");
                                                                   addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_FOR_INCREMENT);:}
                 ;

invocacion ::= cuerpo_invocacion_metodo PUNTO_COMA                         {:System.out.println("[S] estructura: invocacion [tradicional]");:}             
             | THIS PUNTO cuerpo_invocacion_metodo PUNTO_COMA              {:System.out.println("[S] estructura: invocacion [this]");:}
       //      | error                                                       {:System.out.println("[S] error: INVOCATION MALFORMED");:}
             ;

cuerpo_invocacion_var ::= NOMBRE PUNTO cuerpo_invocacion_var                                                                        {:System.out.println("[S] estructura: cuerpo_invocacion_V [recursi var]");:}             
                        | NOMBRE PARENTESIS_A argumentacion PARENTESIS_C PUNTO cuerpo_invocacion_var                                {:System.out.println("[S] estructura: cuerpo_invocacion_V [recursi met]");:}             
                        | NOMBRE                                                                                                     {:System.out.println("[S] estructura: cuerpo_invocacion_V [only var]");:}             
                  //      | error:err                                                                                                  {:System.out.println("[S] error: INVOCATION OF VAR MALFORMED");
                  //                                                                                                                     addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_VAR_INVOCATION);:}
                        ;

cuerpo_invocacion_metodo ::= NOMBRE PUNTO cuerpo_invocacion_metodo                                                                   {:System.out.println("[S] estructura: cuerpo_invocacion_M [recursi var]");:}                
                           | NOMBRE PARENTESIS_A argumentacion PARENTESIS_C PUNTO cuerpo_invocacion_metodo                           {:System.out.println("[S] estructura: cuerpo_invocacion_M [recursi met]");:}             
                           | NOMBRE PARENTESIS_A argumentacion PARENTESIS_C                                                          {:System.out.println("[S] estructura: cuerpo_invocacion_M [only metodo]");:}             
            //               | error                                                                                                   {:System.out.println("[S] error: INVOCATION OF METHOD MALFORMED");:}
                           ;

argumentacion ::= argumentos                            {:System.out.println("[S] substruct: argumentacion [min 1 argu]");:}
                |                                       {:System.out.println("[S] substruct: argumentacion [0 argu]");:}
         //       | error                                 {:System.out.println("[S] error: STRUCT OF ARGUMENTS MALFORMED");:}
                ;

argumentos ::= argumentos COMA argumento                               {:System.out.println("[S] substruct: argumentos [+ 1 argu]");:}
             | argumento                                               {:System.out.println("[S] substruct: argumentos [1 argu]");:}
             | error:err                                               {:System.out.println("[S] error: EXPECTED 1 OR ARGUMENTS LIST");
                                                                         addError(Token.parseToken(err), errleft, errright, SintaxError.ARGUMENTS_SECTION_WITH_ERRORS);:}
             ;
    
argumento ::= contenido_numero                           {:System.out.println("[S] substruct: argumento [cont_#]");:}          
            | contenido_string                           {:System.out.println("[S] substruct: argumento [cont_S]");:}
            | contenido_char                             {:System.out.println("[S] substruct: argumento [cont_C]");:}
            | contenido_boolean                          {:System.out.println("[S] substruct: argumento [cont_B]");:}
            | contenido_object                           {:System.out.println("[S] substruct: argumento [cont_Oc]");:}
            | contenido_objeto                           {:System.out.println("[S] substruct: argumento [cont_O]");:}
            | THIS PUNTO cuerpo_invocacion_metodo        {:System.out.println("[S] substruct: argumento [THIS . IM]");:}
            | cuerpo_invocacion_metodo                   {:System.out.println("[S] substruct: argumento [IM]");:}
            | THIS PUNTO cuerpo_invocacion_var           {:System.out.println("[S] substruct: argumento [THIS . IV]");:}
            | NOMBRE PUNTO cuerpo_invocacion_var         {:System.out.println("[S] substruct: argumento [NOMBRE . IV]");:}
       //     | error                                      {:System.out.println("[S] error: ARGUMENT MUST BE ONE OF EXISTING TYPES");:}
            ;/*no add contenido_var porque los contenidos se llaman directamente sin nada que especifique que s debe agarrar alguno en una sit específica, por lo tanto cont# se encarga de ello xD*/
            /*aquí si hay conflictos deplano lo que haré es dejar contS [a diferencia de condi y autoincre y dejaré solo a los #...]*/

sentencia_control ::= sentencia_if                                                         {:System.out.println("[S] estructura: IF");:}
                    | sentencia_if ELSE cuerpo_estructuras                                 {:System.out.println("[S] estructura: IF-ELSE");:}                    
                    | sentencia_switch                                                     {:System.out.println("[S] estructura: SWITCH");:}
            //        | error                                                                {:System.out.println("[S] error: CONTROL STATEMENT [IF| IF-ELSE||SWITCH] EXPECTED");:}
                    ;

sentencia_if ::= IF PARENTESIS_A contenido_boolean PARENTESIS_C cuerpo_estructuras                              {:System.out.println("[S] substruct: sentencia_if [cont_B]");:}               
               | IF PARENTESIS_A contenido_variable PARENTESIS_C cuerpo_estructuras                             {:System.out.println("[S] substruct: sentencia_if [cont_V]");:}               
          //     | error                                                                                          {:System.out.println("[S] error: IF STATEMENT MALFORMED");:}
               ;

contenido_boolean ::= negaciones PARENTESIS_A contenido_boolean PARENTESIS_C                             {:System.out.println("[S] substruct: contenido_boolean [! ( MC ) ]");:}
                    | PARENTESIS_A contenido_boolean PARENTESIS_C                                        {:System.out.println("[S] substruct: contenido_boolean [( MC )]");:}
                    | contenido_boolean OPERADOR_LOGICO contenido_boolean                                {:System.out.println("[S] substruct: contenido_boolean [ cont_boolean OL cont_boolean]");:}
                    | condicion                                                                          {:System.out.println("[S] substruct: contenido_boolean [condicion]");:}                    
            //        | error                                                                              {:System.out.println("[S] error: BOOLEAN TYPE CONTENT STRUCT MALFORMED");:}
                    ;

condicion ::= contenido_condicion OPERADOR_RELACIONAL opcion_condicion                               {:System.out.println("[S] substruct: condicion [contCondi OR op_condi]");:}
            | contenido_bool OPERADOR_RELACIONAL opcion_condicion                                    {:System.out.println("[S] substruct: condicion [cont_bool OR op_condi]");:}                                
            | contenido_bool                                                                         {:System.out.println("[S] substruct: condicion [cont_bool]");:}               
      //      | error                                                                                  {:System.out.println("[S] error: CONDITION MALFORMED");:}                 
            ;

opcion_condicion ::= contenido_bool                                          {:System.out.println("[S] substruct: op_condicion [cont_bool]");:}                                   
                   | contenido_condicion                                     {:System.out.println("[S] substruct: op_condicion [cont_condi]");:}
        //           | error                                                   {:System.out.println("[S] error: A CONDITION OPTION EXPECTED");:}
                   ;/*1. 10 conflictos*/

/*condicion ::= opcion_condicion OPERADOR_RELACIONAL opcion_condicion                               {:System.out.println("[S] substruct: multiple_condi [parejaC OL parejaC]");:}            
            | contenido_bool 
            ;
            
opcion_condicion ::= contenido_bool
                   | contenido_condicion
                   ;*//*2. 10 conflictos, no cbn nada con la que está arribita*/   

contenido_condicion ::= contenido_numero                                {:System.out.println("[S] substruct: contenido_condi [con_#]");:}
                      | contenido_string                                {:System.out.println("[S] substruct: contenido_condi [cont_S]");:}
                      /*si hay conflicto entre estos... tendré que colocar solo "strings" aquí de todos modos no creo que vayan a colocar una concat en una condición... [igual que en autoincre]*/
                      | contenido_char                                  {:System.out.println("[S] substruct: contenido_condi [cont_C]");:}                      
                      /*para evitar conflictos con nombre [generado por cont#] y booleans*/
                      | contenido_object                                {:System.out.println("[S] substruct: contenido_condi [cont_Oc]");:}
                      | contenido_objeto                                {:System.out.println("[S] substruct: contenido_condi [cont_O]");:}
                      | NOMBRE PUNTO cuerpo_invocacion_var              {:System.out.println("[S] substruct: contenido_condi [NOMBRE . IV]");:}
                      | THIS PUNTO cuerpo_invocacion_var                {:System.out.println("[S] substruct: contenido_condi [THIS . IV]");:}
                      | cuerpo_invocacion_metodo                        {:System.out.println("[S] substruct: contenido_condi [IM]");:}
                      | THIS PUNTO cuerpo_invocacion_metodo             {:System.out.println("[S] substruct: contenido_condi [THIS . IM]");:}
        //              | error                                           {:System.out.println("[S] error: CONDITION CONTENT MUST BE ONE OF ALLOWED TYPES");:}
                      ;

contenido_bool ::= PARENTESIS_A contenido_bool PARENTESIS_C                             {:System.out.println("[S] substruct: cont_bool [ ( cont_bool ) ]");:}
                 | negaciones contenido_bool                                            {:System.out.println("[S] substruct: cont_bool [ ! cont_bool ]");:}
                 | negaciones contenido_variable                                        {:System.out.println("[S] substruct: cont_bool [ ! cont_var ]");:}
                 | BOOLEANO                                                             {:System.out.println("[S] substruct: cont_bool [ BOOLEANO ]");:}
        //         | error                                                                {:System.out.println("[S] error: EXPECTED A TYPE OF BOOLEAN");:}
                 ;
/*de esta manera restringo que solo los booleanos puedan ser negados individualmente... y sin caer en conflictos por el nombre generado en contenido_numeros...*/

negaciones ::= negaciones NO                                  {:System.out.println("[S] substruct: negaciones [LISTA]");:}
             | NO                                             {:System.out.println("[S] substruct: negaciones [UNICA]");:}
        //     | error                                          {:System.out.println("[S] error: NEGATIONS MALFORMED");:}
             ;

sentencia_switch ::= SWITCH PARENTESIS_A contenido_switch PARENTESIS_C LLAVE_A cuerpo_switch LLAVE_C                             {:System.out.println("[S] substruct: sentencia_switch");:}
        //           | error                                                                                                       {:System.out.println("[S] error: BAD STRUCT OF \"SWITCH\" CONTROL STATEMENT");:}
                   ;

cuerpo_switch ::= casos_normales caso_default                               {:System.out.println("[S] substruct: cuerpo_switch [CN + posible CD]");:}
                | caso_default                                              {:System.out.println("[S] substruct: cuerpo_switch [posible CD o nada]");:}
                | error:err                                                 {:System.out.println("[S] error: SWITCH's BODY MALDORMED");
                                                                              addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_SWITCHs_BODY);:}
                ;

casos_normales ::= casos_normales caso                               {:System.out.println("[S] substruct: casos_normales [LISTA]");:}
                 | caso                                              {:System.out.println("[S] substruct: casos_normales [UNICO]");:}
        //        | error:err                                         {:System.out.println("[S] error: CASE OR LIST OF THEM WHITH ERRORS");
        //                                                               addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_CASE_LIST);:}
                 ;//escogimos el general, pensando en que de esa manera se podrá evitar que el intento de recu, se propage hasta el método... xD

/*vamos a ver si esto de casos y caso_def no da prob por repitencia, si si entonces crearás otra RP donde se tenga BG y nada xD [ambos usarían la misma RP]*/
caso ::= CASE contenido_switch DOS_PUNTOS bloque_general                                 {:System.out.println("[S] substruct: caso (CB)");:}
       | CASE contenido_switch DOS_PUNTOS                                                {:System.out.println("[S] substruct: caso (SB)");:} 
    //   | error                                                                           {:System.out.println("[S] error: CASE's STRUCT MALFORMED");:}
       ;

caso_default ::= DEFAULT DOS_PUNTOS bloque_general                                  {:System.out.println("[S] substruct: caso_default [existente (CB)]");:}
               | DEFAULT DOS_PUNTOS                                                 {:System.out.println("[S] substruct: caso_default [existente (SB)]");:} 
               |                                                                    {:System.out.println("[S] substruct: caso_default [ausente]");:}
        //       | error                                                              {:System.out.println("[S] error: DEAFULT CASE's STRUCT MALFORMED");:}
               ;

contenido_switch ::= contenido_string                               {:System.out.println("[S] substruct: contenido_switch [cont_S]");:}
                   | contenido_numero                               {:System.out.println("[S] substruct: contenido_switch [cont_#]");:}
                   | contenido_char                                 {:System.out.println("[S] substruct: contenido_switch [cont_C]");:}
                   | THIS PUNTO cuerpo_invocacion_var               {:System.out.println("[S] substruct: contenido_switch [THIS . IV]");:}
                   | NOMBRE PUNTO cuerpo_invocacion_var             {:System.out.println("[S] substruct: contenido_switch [NOMBRE . IV]");:}
                   | THIS PUNTO cuerpo_invocacion_metodo            {:System.out.println("[S] substruct: contenido_switch [THIS . IM]");:}
                   | cuerpo_invocacion_metodo                       {:System.out.println("[S] substruct: contenido_switch [IM]");:}
                   | error:err                                      {:System.out.println("[S] error: A SWITCH MUST RECEIVED A STRING|NUMBER|CHAR TYPE TO EVALUATE");
                                                                      addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_TYPE_TO_EVALUATE_ON_SWITCH);:}
                   ;/*mientras no sepa como hacer para que contenido# no genere un "nombre" solito, no incluiré contenido_Var*/

cuerpo_estructuras ::= LLAVE_A bloque_general LLAVE_C                              {:System.out.println("[S] substruct: cuerpo_estructuras [CB]");:}
                     | LLAVE_A LLAVE_C                                             {:System.out.println("[S] substruct: cuerpo_estructuras [SB]");:}
                     | error:err LLAVE_C                                           {:System.out.println("[S] error: LOOP OR CONTROL STATEMENT BODY WITH ERRORS");
                                                                                     addError(Token.parseToken(err), errleft, errright, SintaxError.BAD_BODY_STRUCT);:}
                     ;

/*esta RP es para los ciclos y estructuras de control...*/
bloque_general ::= bloque retorno                                {:System.out.println("[S] substruct: bloque_general [CR [comp o parada]]");:}
                 | bloque                                        {:System.out.println("[S] substruct: bloque_general [SR]");:}
                 | retorno                                       {:System.out.println("[S] substruct: bloque_general [SB y CR]");:}
          //       | error                                         {:System.out.println("[S] error: BLOCK OF LOOP OR CONTROL STATEMENT MALFORMED");:}
                 /*ya verifiqué y los ciclos tb pueden solo retornar...*/
                 ;

retorno ::= retorno_compuesto                                {:System.out.println("[S] substruct: retorno [compuesto]");:}
          | parada PUNTO_COMA                                {:System.out.println("[S] substruct: retorno [parada [simple]]");:}
     //     | error                                            {:System.out.println("[S] error: RETURN OR BREAK WHITH ERRORS");:}
          ;

retorno_compuesto ::= retorno_numero                                                                    {:System.out.println("[S] substruct: retorno_compuesto: retorno_#");:}
                    | retorno_string                                                                    {:System.out.println("[S] substruct: retorno_compuesto: retorno_S");:}
                    | retorno_char                                                                      {:System.out.println("[S] substruct: retorno_compuesto: retorno_C");:}
                    | retorno_boolean                                                                   {:System.out.println("[S] substruct: retorno_compuesto: retorno_B");:}
                    | retorno_object                                                                    {:System.out.println("[S] substruct: retorno_compuesto: retorno_Oc");:}
                    | retorno_objeto                                                                    {:System.out.println("[S] substruct: retorno_compuesto: retorno_O");:}
                    | RETURN invocacion                                                                 {:System.out.println("[S] substruct: retorno_compuesto: RETURN invocacion");:} 
                    | RETURN NOMBRE PUNTO cuerpo_invocacion_var PUNTO_COMA                              {:System.out.println("[S] substruct: retorno_compuesto: RETURN IV ;");:} 
                    | RETURN THIS PUNTO cuerpo_invocacion_var PUNTO_COMA                                {:System.out.println("[S] substruct: retorno_compuesto: RETURN IV ;");:}
         //           | error                                    {:System.out.println("[S] error: A COMPOUND RETURN MUST BE ONE OF ALLOWED TYPES");:}
                    ;

retorno_variable ::= RETURN contenido_variable PUNTO_COMA                             {:System.out.println("[S] substruct: retorno_V");:}
         //          | error                                                            {:System.out.println("[S] error: VARIABLE RETURN MALFORMED");:}
                   ;/*aunque cont# permita esto, si no se juntan a todos en una sola RP este debe existir por los demás xD*/

retorno_numero ::= RETURN contenido_numero PUNTO_COMA                                 {:System.out.println("[S] substruct: retorno_#");:}
         //        | error                                                              {:System.out.println("[S] error: NUMBER's RETURN MALFORMED");:}
                 ;

retorno_string ::= RETURN contenido_string PUNTO_COMA                                 {:System.out.println("[S] substruct: retorno_S");:}
         //        | error                                                              {:System.out.println("[S] error: STRING's RETURN MALFORMED");:}
                 ;

retorno_char ::= RETURN contenido_char PUNTO_COMA                                     {:System.out.println("[S] substruct: retorno_C");:}
         //      | error                                                                {:System.out.println("[S] error: CHAR's RETURN MALFORMED");:}
               ;

retorno_boolean ::= RETURN contenido_boolean PUNTO_COMA                               {:System.out.println("[S] substruct: retorno_B");:}
         //         | error                                                             {:System.out.println("[S] error: BOOLEAN's RETURN MALFORMED");:}
                  ;

retorno_object ::= RETURN contenido_object PUNTO_COMA                                 {:System.out.println("[S] substruct: retorno_Oc");:}
         //        | error                                                              {:System.out.println("[S] error: OBJECT's RETURN MALFORMED");:}
                 ;

retorno_objeto ::= RETURN contenido_objeto PUNTO_COMA                                 {:System.out.println("[S] substruct: retorno_O");:}
         //        | error                                                              {:System.out.println("[S] error: CUSTOM OBJECT RETURN MALFORMED");:}
                 ;

parada ::= RETURN                                   {:System.out.println("[S] substruct: parada [RETURN]");:}
         | BREAK                                    {:System.out.println("[S] substruct: parada [BREAK]");:}
    //     | error                                    {:System.out.println("[S] error: EXPECTED A DETENTION TYPE [RETURN|BREAK]");:}
         ;